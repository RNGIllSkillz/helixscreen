#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-or-later
#
# SysV init script for HelixScreen
# For use on systems without systemd (e.g., FlashForge AD5M with BusyBox init)
#
# Installation varies by firmware:
#   Forge-X:      /etc/init.d/S90helixscreen -> /opt/helixscreen
#   Klipper Mod:  /etc/init.d/S80helixscreen -> /root/printer_software/helixscreen
#
# The install.sh script automatically selects the correct paths.
# DAEMON_DIR below is updated by the installer to match the install location.
#
# Usage:
#   /etc/init.d/S*helixscreen start|stop|restart|status
#
# Note: S80/S90 prefix ensures we start after network and Moonraker

NAME="helixscreen"
DESC="HelixScreen 3D Printer Touch UI"
DAEMON_DIR="/opt/helixscreen"  # Updated by installer for different firmware
DAEMON="${DAEMON_DIR}/bin/helix-screen"
SPLASH="${DAEMON_DIR}/bin/helix-splash"
WATCHDOG="${DAEMON_DIR}/bin/helix-watchdog"
LAUNCHER="${DAEMON_DIR}/bin/helix-launcher.sh"
PIDFILE="/var/run/${NAME}.pid"
LOGFILE="/tmp/helixscreen.log"

# Override asset directory if ui_xml/assets/config are not under DAEMON_DIR
# Export so helix-screen picks it up at startup
# HELIX_DATA_DIR="/mnt/data/helixscreen"
# export HELIX_DATA_DIR

# ForgeX backlight control paths (AD5M with ForgeX firmware)
FORGEX_BACKLIGHT="/root/printer_data/py/backlight.py"

# Check if binary exists
[ -x "$DAEMON" ] || exit 0

# Known competing screen UIs to stop
COMPETING_UIS="guppyscreen GuppyScreen KlipperScreen klipperscreen featherscreen FeatherScreen"

# Stop competing screen UIs
stop_competing_uis() {
    # Stop stock FlashForge firmware UI (AD5M/Adventurer 5M)
    # ffstartup-arm is the startup manager that launches firmwareExe (the stock Qt UI)
    if [ -f /opt/PROGRAM/ffstartup-arm ]; then
        echo "Stopping stock FlashForge UI..."
        if command -v killall >/dev/null 2>&1; then
            killall firmwareExe 2>/dev/null || true
            killall ffstartup-arm 2>/dev/null || true
        else
            for pid in $(pidof firmwareExe 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
            for pid in $(pidof ffstartup-arm 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
        fi
    fi

    # On Klipper Mod, stop Xorg first (required for framebuffer access)
    # Xorg takes over /dev/fb0 layer, preventing direct framebuffer rendering
    if [ -x "/etc/init.d/S40xorg" ]; then
        echo "Stopping Xorg (Klipper Mod)..."
        /etc/init.d/S40xorg stop 2>/dev/null || true
        # Kill any remaining Xorg processes
        if command -v killall >/dev/null 2>&1; then
            killall Xorg 2>/dev/null || true
            killall X 2>/dev/null || true
        else
            for pid in $(pidof Xorg 2>/dev/null) $(pidof X 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
        fi
    fi

    for ui in $COMPETING_UIS; do
        # Check init.d scripts
        for initscript in /etc/init.d/S*${ui}* /opt/config/mod/.root/S*${ui}*; do
            if [ -x "$initscript" ] 2>/dev/null; then
                echo "Stopping competing UI: $initscript"
                "$initscript" stop 2>/dev/null || true
            fi
        done
        # Kill any remaining processes (BusyBox compatible - no pkill)
        if command -v killall >/dev/null 2>&1; then
            killall "$ui" 2>/dev/null || true
        else
            # BusyBox fallback - use pidof + kill
            for pid in $(pidof "$ui" 2>/dev/null); do
                kill "$pid" 2>/dev/null || true
            done
        fi
    done

    # Kill python-based KlipperScreen (runs as python3 process)
    if command -v killall >/dev/null 2>&1; then
        # Match python processes running screen.py (KlipperScreen entry point)
        for pid in $(ps 2>/dev/null | grep -E 'python.*screen\.py' | grep -v grep | awk '{print $1}'); do
            echo "Killing KlipperScreen python process (PID $pid)"
            kill "$pid" 2>/dev/null || true
        done
    fi

    # Brief pause to let processes exit
    sleep 1
}

# ForgeX chroot location (AD5M with ForgeX firmware)
FORGEX_CHROOT="/data/.mod/.forge-x"

# Enable display backlight (for ForgeX firmware on AD5M)
# ForgeX may leave the backlight off when display mode is STOCK,
# so we explicitly enable it before starting HelixScreen.
# NOTE: FORGEX_BACKLIGHT is the path INSIDE the chroot, not the host path!
enable_backlight() {
    # ForgeX stores backlight.py inside a chroot environment
    # Must run via chroot for the ioctl to work
    # Check the FULL path (chroot + script) for existence
    local full_backlight_path="${FORGEX_CHROOT}${FORGEX_BACKLIGHT}"
    if [ -d "$FORGEX_CHROOT" ] && [ -x "$full_backlight_path" ]; then
        echo "Enabling backlight via ForgeX chroot..."
        /usr/sbin/chroot "$FORGEX_CHROOT" "$FORGEX_BACKLIGHT" 100 2>/dev/null || true
        return 0
    fi

    # Log if we couldn't enable backlight (helps debug boot issues)
    echo "Warning: Could not enable backlight (chroot=$FORGEX_CHROOT, script=$full_backlight_path)"
    return 1
}

# Start splash screen (if available)
# Returns the --splash-pid argument on stdout (for capture by caller)
# Status messages go to stderr to avoid polluting the return value
start_splash() {
    if [ -x "$SPLASH" ]; then
        echo "Starting splash screen..." >&2
        # Redirect splash output to /dev/null to prevent any contamination of captured stdout
        # Splash auto-detects resolution from display hardware
        "$SPLASH" >/dev/null 2>&1 &
        SPLASH_PID=$!
        echo "$SPLASH_PID" > /var/run/helix-splash.pid
        echo "--splash-pid=$SPLASH_PID"
    fi
}

# Stop splash screen
stop_splash() {
    if [ -f /var/run/helix-splash.pid ]; then
        SPLASH_PID=$(cat /var/run/helix-splash.pid)
        kill "$SPLASH_PID" 2>/dev/null || true
        rm -f /var/run/helix-splash.pid
    fi
}

# Wait for Moonraker to be ready (ForgeX only)
# On memory-constrained systems like AD5M (107MB RAM), starting helix-screen
# while moonraker is still initializing causes severe swap thrashing.
# By waiting here with only the lightweight splash running, moonraker can
# start without competition, dramatically improving boot time.
wait_for_moonraker() {
    # Only wait on ForgeX - it has the memory constraints
    # Other systems (Klipper Mod on Pi) have plenty of RAM
    if [ ! -d "$FORGEX_CHROOT" ]; then
        return 0
    fi

    # Check if moonraker is even configured to run
    # ForgeX can disable moonraker via variables.cfg
    local moonraker_disabled
    moonraker_disabled=$(/usr/sbin/chroot "$FORGEX_CHROOT" /bin/sh -c \
        '/opt/config/mod/.shell/commands/zconf.sh /opt/config/mod_data/variables.cfg --get "disable_moonraker" "0"' 2>/dev/null)
    if [ "$moonraker_disabled" = "1" ]; then
        echo "Moonraker disabled, skipping wait"
        return 0
    fi

    echo "Waiting for Moonraker (reduces memory pressure)..."
    local timeout=120  # 2 minutes max - moonraker can be slow on first boot
    local waited=0
    while [ $waited -lt $timeout ]; do
        # Check if moonraker is responding
        # Use wget since curl isn't available on BusyBox base system
        if wget -q -O /dev/null --timeout=1 http://localhost:7125/server/info 2>/dev/null; then
            echo "Moonraker ready after ${waited}s"
            return 0
        fi
        sleep 1
        waited=$((waited + 1))
        # Progress indicator every 10 seconds
        if [ $((waited % 10)) -eq 0 ]; then
            echo "  Still waiting for Moonraker... (${waited}s)"
        fi
    done

    echo "Warning: Moonraker not ready after ${timeout}s, starting anyway"
    return 1
}

start() {
    echo "Starting $DESC..."

    # Create flag file so ForgeX S99root skips screen output
    touch /tmp/helixscreen_active

    # Stop any competing UIs first
    stop_competing_uis

    # Enable backlight (ForgeX may leave it off)
    enable_backlight

    # Check if already running
    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$NAME is already running (PID $PID)"
            return 0
        fi
        rm -f "$PIDFILE"
    fi

    cd "$DAEMON_DIR"

    # Start splash screen early (before launcher) so it's visible during load
    # Set HELIX_NO_SPLASH=1 to disable splash (for debugging backlight issues)
    # Splash auto-detects resolution from display hardware
    EARLY_SPLASH_PID=""
    if [ -x "$SPLASH" ] && [ "${HELIX_NO_SPLASH:-0}" != "1" ]; then
        echo "Starting splash screen..."
        "$SPLASH" >/dev/null 2>&1 &
        EARLY_SPLASH_PID=$!
        echo "$EARLY_SPLASH_PID" > /var/run/helix-splash.pid
    elif [ "${HELIX_NO_SPLASH:-0}" = "1" ]; then
        echo "Splash screen disabled (HELIX_NO_SPLASH=1)"
    fi

    # Fork the moonraker wait + helix-screen launch into background
    # This lets S90 exit so S99 can run and actually start moonraker
    # Without this, we'd deadlock: S90 waits for moonraker, S99 starts moonraker but can't run until S90 finishes
    (
        # Wait for Moonraker before starting the main UI
        # This lets moonraker initialize without memory competition from helix-screen
        if [ "${HELIX_NO_MOONRAKER_WAIT:-0}" != "1" ]; then
            wait_for_moonraker
        fi

        # Use launcher script if available (handles watchdog)
        # Pass early splash PID so watchdog doesn't start another splash
        if [ -x "$LAUNCHER" ]; then
            if [ -n "$EARLY_SPLASH_PID" ]; then
                export HELIX_SPLASH_PID="$EARLY_SPLASH_PID"
            fi
            cd "$DAEMON_DIR" && exec $LAUNCHER
        else
            # Fallback: start daemon directly
            cd "$DAEMON_DIR" && exec "$DAEMON" --splash-pid="$EARLY_SPLASH_PID"
        fi
    ) >> "$LOGFILE" 2>&1 &
    echo $! > "$PIDFILE"

    # Wait briefly and check if started
    sleep 2
    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$NAME started (PID $PID)"
            return 0
        fi
    fi

    echo "Failed to start $NAME"
    stop_splash
    return 1
}

stop() {
    echo "Stopping $DESC..."

    # Remove flag file
    rm -f /tmp/helixscreen_active

    # Stop splash first
    stop_splash

    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            kill "$PID"
            # Wait for process to exit
            for i in 1 2 3 4 5; do
                if ! kill -0 "$PID" 2>/dev/null; then
                    break
                fi
                sleep 1
            done
            # Force kill if still running
            if kill -0 "$PID" 2>/dev/null; then
                kill -9 "$PID" 2>/dev/null || true
            fi
        fi
        rm -f "$PIDFILE"
    fi

    # Also kill by name in case PID file is stale
    # Kill watchdog first to prevent crash dialog flash during clean shutdown
    if command -v killall >/dev/null 2>&1; then
        killall helix-watchdog 2>/dev/null || true
        killall helix-screen 2>/dev/null || true
        killall helix-splash 2>/dev/null || true
    else
        for pid in $(pidof helix-watchdog 2>/dev/null); do
            kill "$pid" 2>/dev/null || true
        done
        for pid in $(pidof helix-screen 2>/dev/null); do
            kill "$pid" 2>/dev/null || true
        done
        for pid in $(pidof helix-splash 2>/dev/null); do
            kill "$pid" 2>/dev/null || true
        done
    fi

    echo "$NAME stopped"
}

restart() {
    stop
    sleep 1
    start
}

status() {
    if [ -f "$PIDFILE" ]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$NAME is running (PID $PID)"
            return 0
        fi
        echo "$NAME is not running (stale PID file)"
        return 1
    fi

    # Check if running without PID file
    if command -v pidof >/dev/null 2>&1; then
        PID=$(pidof helix-screen 2>/dev/null)
        if [ -n "$PID" ]; then
            echo "$NAME is running (PID $PID) [no PID file]"
            return 0
        fi
    fi

    echo "$NAME is not running"
    return 1
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart|reload)
        restart
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 1
        ;;
esac

exit $?
